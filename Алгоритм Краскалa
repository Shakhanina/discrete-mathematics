import math
# список ребер графа (1 значение(вес), 2 значение (вершина 1), 3 значение (вершина 2))
R = [(math.inf, -1, -1), (15, 1, 2), (14, 1, 5), (23, 1, 4), (19, 2, 3), (16, 2, 4),
     (15, 2, 5), (14, 3, 5), (26, 3, 6), (25, 4, 5), (23, 4, 7), (20, 4, 8),
     (24, 5, 6), (27, 5, 8), (18, 5, 9), (14, 7, 8), (18, 8, 9)]

R_sort = sorted(R, key=lambda x: x[0])
# список соединенных вершин
U = set()
# словарь списка изолированных групп вершин
D = {}
# список ребер остова
T = []      

for i in R_sort:
    if i[1] not in U or i[2] not in U:  # проверка для исключения циклов 
        if i[1] not in U and i[2] not in U: # если обе вершины не соединены, то
            D[i[1]] = [i[1], i[2]]          # формируем в словаре ключ с номерами вершин
            D[i[2]] = D[i[1]]               # и связываем их с одним и тем же списком вершин
        else:                          
            if not D.get(i[1]):             # если в словаре нет первой вершины, то
                D[i[2]].append(i[1])        # добавляем в список первую вершину
                D[i[1]] = D[i[2]]           # и добавляем ключ с номером первой вершины
            else:
                D[i[1]].append(i[2])        # иначе, все то же самое делаем со второй вершиной
                D[i[2]] = D[i[1]]

        # добавляем ребро 
        T.append(i)
        # добавляем вершины в множество U
        U.add(i[1])             
        U.add(i[2])

for i in R_sort:    # проходим по ребрам второй раз и объединяем разрозненные группы вершин
    if i[2] not in D[i[1]]:     # если вершины принадлежат разным группам, то объединяем
        T.append(i)             # добавляем ребро в остов
        gr1 = D[i[1]]
        D[i[1]] += D[i[2]]      # объединем списки двух групп вершин
        D[i[2]] += gr1
print(T)
